import os
import logging
import httpx

from aiogram import Bot, Dispatcher
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Update, Message
from aiogram.filters import CommandStart
from fastapi import FastAPI, Request
from dotenv import load_dotenv

# –ó–∞–≥—Ä—É–∑–∫–∞ .env
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")

if not BOT_TOKEN:
    raise RuntimeError("‚ùå BOT_TOKEN is not set")
if not WEBHOOK_URL:
    raise RuntimeError("‚ùå WEBHOOK_URL is not set")
if not OPENROUTER_API_KEY:
    raise RuntimeError("‚ùå OPENROUTER_API_KEY is not set")

WEBHOOK_PATH = f"/webhook/{BOT_TOKEN}"
FULL_WEBHOOK_URL = f"{WEBHOOK_URL}{WEBHOOK_PATH}"

# –õ–æ–≥–∏
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("bot")

# –ë–æ—Ç –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# FastAPI
app = FastAPI()

# –ö–æ–º–∞–Ω–¥–∞ /start
@dp.message(CommandStart())
async def cmd_start(message: Message):
    await message.answer("üëã –ü—Ä–∏–≤–µ—Ç! –Ø AI-–ø–æ–º–æ—â–Ω–∏–∫. –ó–∞–¥–∞–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å —Ñ–∞–π–ª!")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
@dp.message(lambda msg: msg.text)
async def ask_ai(message: Message):
    try:
        headers = {
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "Content-Type": "application/json"
        }
        data = {
            "model": "mistralai/mistral-7b-instruct",
            "messages": [
                {"role": "system", "content": "–¢—ã –ø–æ–ª–µ–∑–Ω—ã–π AI-–ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤."},
                {"role": "user", "content": message.text}
            ]
        }

        async with httpx.AsyncClient() as client:
            response = await client.post(
                "https://openrouter.ai/api/v1/chat/completions",
                headers=headers,
                json=data
            )
        result = response.json()

        if "choices" in result:
            reply = result["choices"][0]["message"]["content"]
            await message.answer(reply)
        else:
            logger.error(f"–û—à–∏–±–∫–∞ OpenRouter: {result}")
            await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç –º–æ–¥–µ–ª–∏.")
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ OpenRouter")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞.")

# –ó–∞–ø—É—Å–∫ webhook
@app.on_event("startup")
async def on_startup():
    await bot.set_webhook(FULL_WEBHOOK_URL)
    logger.info(f"‚úÖ Webhook —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {FULL_WEBHOOK_URL}")

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π Telegram —á–µ—Ä–µ–∑ FastAPI
@app.post(WEBHOOK_PATH)
async def process_webhook(request: Request):
    try:
        data = await request.json()
        update = Update.model_validate(data)
        await dp.feed_update(bot, update)
    except Exception as e:
        logger.exception(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}")
    return {"ok": True}
